import{_ as u,r,o as h,c as d,a as e,b as t,w as a,e as n,d as o}from"./app.ff0cf306.js";const p={},m=n(`<h1 id="long-polling-vs-webhooks" tabindex="-1"><a class="header-anchor" href="#long-polling-vs-webhooks" aria-hidden="true">#</a> Long Polling vs. Webhooks</h1><p>There are two ways how your bot can receive messages from the Telegram servers. They are called <em>long polling</em> and <em>webhooks</em>. grammY supports both of these two ways, while long polling is the default.</p><p>This section first describes what long polling and webhooks actually are, and in turn outlines some of the advantages and disadvantages of using one or the other deployment method. It will also cover how to use them with grammY.</p><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p>You can think of the whole webhooks vs. long polling discussion as a question of what <em>deployment type</em> to use. In other words, there are two fundamentally different ways to host your bot (run it on some server), and they differ in the way how the messages reach your bot, and can be processed by grammY.</p><p>This choice matters a lot when you need to decide where to host your bot. For instance, some infrastructure providers only support one of the two deployment types.</p><p>Your bot can either pull them in (long polling), or the Telegram servers can push them to your bot (webhooks).</p><blockquote><p>If you already know how these things work, scroll down to see how to use <a href="#how-to-use-long-polling">long polling</a> or <a href="#how-to-use-webhooks">webhooks</a> with grammY.</p></blockquote><h2 id="how-does-long-polling-work" tabindex="-1"><a class="header-anchor" href="#how-does-long-polling-work" aria-hidden="true">#</a> How Does Long Polling Work?</h2><p><em>Imagine you\u2019re getting yourself a scoop of ice cream in your trusted ice cream parlor. You walk up to the employee and ask for your favorite type of ice cream. Unfortunately, he lets you know that it is out of stock.</em></p><p><em>The next day, you\u2019re craving that delicious ice cream again, so you go back to the same place and ask for the same ice cream. Good news! They restocked over night so you can enjoy your salted caramel ice cream today! Yummy.</em></p><p><strong>Polling</strong> means that grammY proactively sends a request to Telegram, asking for new updates (think: messages). If no messages are there, Telegram will return an empty list, indicating that no new messages were sent to your bot since the last time you asked.</p><p>When grammY sends a request to Telegram and new messages have been sent to your bot in the meantime, Telegram will return them as an array of up to 100 update objects.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                   _____________
|            |                                   |           |
|            |   &lt;--- are there messages? ---    |           |
|            |    ---       nope.         ---&gt;   |           |
|            |                                   |           |
|            |   &lt;--- are there messages? ---    |           |
|  Telegram  |    ---       nope.         ---&gt;   |    Bot    |
|            |                                   |           |
|            |   &lt;--- are there messages? ---    |           |
|            |    ---  yes, here you go   ---&gt;   |           |
|            |                                   |           |
|____________|                                   |___________|
</code></pre></div><p>It is immediately obvious that this has some drawbacks. Your bot only receives new messages every time it asks, i.e. every few seconds or so. To make your bot respond faster, you could just send more requests and not wait as long between them. We could for example ask for new messages every millisecond! What could go wrong\u2026</p><p>Instead of deciding to spam the Telegram servers, we will use <em>long polling</em> instead of regular (short) polling.</p><p><strong>Long polling</strong> means that grammY proactively sends a request to Telegram, asking for new updates. If no messages are there, Telegram will keep the connection open until new messages arrive, and then respond to the request with those new messages.</p><p><em>Time for ice cream again! The employee already greets you with your first name by now. Asked about some ice cream of your favorite kind, the employee smiles at you and freezes. In fact, you don\u2019t get any response at all. So you decide to wait, firmly smiling back. And you wait. And wait.</em></p><p><em>Some hours before the next sunrise, a truck of a local food delivery company arrives and brings a couple of large boxes into the parlor\u2019s storage room. They read <strong>ice cream</strong> on the outside. The employee finally starts to move again. \u201COf course we have salted caramel! Two scoops with sprinkles, the usual?\u201D</em></p><p><em>As if nothing had happened, you enjoy your ice cream while leaving the world\u2019s most unrealistic ice cream parlor.</em></p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                   _____________
|            |                                   |           |
|            |   &lt;--- are there messages? ---    |           |
|            |   .                               |           |
|            |   .                               |           |
|            |   .     *both waiting*            |           |
|  Telegram  |   .                               |    Bot    |
|            |   .                               |           |
|            |   .                               |           |
|            |    ---  yes, here you go   ---&gt;   |           |
|            |                                   |           |
|____________|                                   |___________|
</code></pre></div>`,21),_=o("Note that in reality, no connection would be kept open for hours. Long polling requests have a default timeout of 30 seconds (in order to avoid a number of "),g={href:"https://tools.ietf.org/id/draft-loreto-http-bidirectional-07.html#timeouts",target:"_blank",rel:"noopener noreferrer"},w=o("technical problems"),y=o("). If no new messages are returned after this period of time, then the request will be cancelled and resent\u2014but the general concept stays the same."),k=n(`<p>Using long polling, you don\u2019t need to spam Telegram\u2019s servers, and still you get new messages immediately! Nifty. This is what grammY does by default when you run <code>bot<wbr>.start()</code>.</p><h2 id="how-do-webhooks-work" tabindex="-1"><a class="header-anchor" href="#how-do-webhooks-work" aria-hidden="true">#</a> How Do Webhooks Work?</h2><p><em>After this terrifying experience (a whole night without ice cream!), you\u2019d prefer not to ask anyone about ice cream at all anymore. Wouldn\u2019t it be cool if the ice cream could come to you?</em></p><p>Setting up a <strong>webhook</strong> means that you will provide Telegram with a URL that is accessible from the public internet. Whenever a new message is sent to your bot, Telegram (and not you!) will take the initiative and send a request with the update object to your server. Nice, heh?</p><p><em>You decide to walk to the ice cream parlor one very last time. You tell your friend behind the counter where you live. He promises to head over to your apartment personally whenever new ice cream is there (because it would melt in the mail). Cool guy.</em></p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                   _____________
|            |                                   |           |
|            |                                   |           |
|            |                                   |           |
|            |         *both waiting*            |           |
|            |                                   |           |
|  Telegram  |                                   |    Bot    |
|            |                                   |           |
|            |                                   |           |
|            |    ---  hi, new message   ---&gt;    |           |
|            |   &lt;---    thanks dude     ---     |           |
|____________|                                   |___________|
</code></pre></div><h2 id="comparison" tabindex="-1"><a class="header-anchor" href="#comparison" aria-hidden="true">#</a> Comparison</h2><p><strong>The main advantage of long polling over webhooks is that it is simpler.</strong> You don\u2019t need a domain or a public URL. You don\u2019t need to fiddle around with setting up SSL certificates in case you\u2019re running your bot on a VPS. Use <code>bot<wbr>.start()</code> and everything will work, no further configuration required. Under load, you are in complete control of how many messages you can process.</p><p>Places where long polling works well include:</p><ul><li>During development on your local machine.</li><li>On majority of servers.</li><li>On hosted \u201Cbackend\u201D instances, i.e. machines that actively run your bot 24/7.</li></ul>`,10),b=e("strong",null,"The main advantage of webhooks over long polling is that they are cheaper.",-1),f=o(" You save a ton of superfluous requests. You don\u2019t need to keep a network connection open at all times. You can use services that automatically scale your infrastructure down to zero when no requests are coming. If you want to, you can even "),v=e("a",{href:"#webhook-reply"},"make an API call when responding to the Telegram request",-1),T=o(", even though this has a number of drawbacks. Check out the configuration option "),q={href:"https://doc.deno.land/https://deno.land/x/grammy/mod.ts/~/ApiClientOptions#canUseWebhookReply",target:"_blank",rel:"noopener noreferrer"},x=o("here"),I=o("."),Y=e("p",null,"Places where webhooks work well include:",-1),W=e("ul",null,[e("li",null,"On servers with SSL certificates."),e("li",null,"On hosted \u201Cfrontend\u201D instances that scale according to their load."),e("li",null,"On serverless platforms, such as cloud functions or programmable edge networks.")],-1),C=e("h2",{id:"i-still-have-no-idea-what-to-use",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#i-still-have-no-idea-what-to-use","aria-hidden":"true"},"#"),o(" I Still Have No Idea What to Use")],-1),A=e("p",null,[o("Then go for long polling. If you don\u2019t have a good reason to use webhooks, then note that there are no major drawbacks to long polling, and\u2014according to our experience\u2014you will spend much less time fixing things. Webhooks can be a bit nasty from time to time (see "),e("a",{href:"#ending-webhook-requests-in-time"},"below"),o(").")],-1),S=o("Whatever you choose, if you ever run into serious problems, it should not be too hard to switch to the other deployment type after the fact. With grammY, you only have to touch a few lines of code. The setup of your "),j=o("middleware"),L=o(" is the same."),O=n(`<h2 id="how-to-use-long-polling" tabindex="-1"><a class="header-anchor" href="#how-to-use-long-polling" aria-hidden="true">#</a> How to Use Long Polling</h2><p>Call</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>bot<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>to run your bot with a very simple form of long polling. It processes all updates sequentially. This makes your bot very easy to debug, and all behavior very predictable, because there is no concurrency involved.</p>`,4),R=o("If you want your messages to be handled concurrently by grammY, or you worry about throughput, check out the section about "),B=o("grammY runner"),H=o("."),P=n('<h2 id="how-to-use-webhooks" tabindex="-1"><a class="header-anchor" href="#how-to-use-webhooks" aria-hidden="true">#</a> How to Use Webhooks</h2><p>If you want to run grammY with webhooks, you can integrate your bot into a web server. We therefore expect you to be able to start a simple web server with a framework of your choice.</p><p>Every grammY bot can be converted to middleware for a number of web frameworks, including <code>express</code>, <code>koa</code>/<code>oak</code>, and more. You can import the <code>webhook<wbr>Callback</code> function from grammY to convert your bot to middleware for the respective framework.</p>',3),N=e("div",{class:"language-typescript ext-ts line-numbers-mode"},[e("pre",{class:"language-typescript"},[e("code",null,[e("span",{class:"token keyword"},"import"),o(" express "),e("span",{class:"token keyword"},"from"),o(),e("span",{class:"token string"},'"express"'),e("span",{class:"token punctuation"},";"),o(`

`),e("span",{class:"token keyword"},"const"),o(" app "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token function"},"express"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(),e("span",{class:"token comment"},"// or whatever you're using"),o(`
app`),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"use"),e("span",{class:"token punctuation"},"("),o("express"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"json"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(),e("span",{class:"token comment"},"// parse the JSON request body"),o(`

`),e("span",{class:"token comment"},'// "express" is also used as default if no argument is given.'),o(`
app`),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"use"),e("span",{class:"token punctuation"},"("),e("span",{class:"token function"},"webhookCallback"),e("span",{class:"token punctuation"},"("),o("bot"),e("span",{class:"token punctuation"},","),o(),e("span",{class:"token string"},'"express"'),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),U=e("div",{class:"language-javascript ext-js line-numbers-mode"},[e("pre",{class:"language-javascript"},[e("code",null,[e("span",{class:"token keyword"},"const"),o(" express "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token function"},"require"),e("span",{class:"token punctuation"},"("),e("span",{class:"token string"},'"express"'),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(`

`),e("span",{class:"token keyword"},"const"),o(" app "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token function"},"express"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(),e("span",{class:"token comment"},"// or whatever you're using"),o(`
app`),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"use"),e("span",{class:"token punctuation"},"("),o("express"),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"json"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(),e("span",{class:"token comment"},"// parse the JSON request body"),o(`

`),e("span",{class:"token comment"},'// "express" is also used as default if no argument is given.'),o(`
app`),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"use"),e("span",{class:"token punctuation"},"("),e("span",{class:"token function"},"webhookCallback"),e("span",{class:"token punctuation"},"("),o("bot"),e("span",{class:"token punctuation"},","),o(),e("span",{class:"token string"},'"express"'),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),E=e("div",{class:"language-typescript ext-ts line-numbers-mode"},[e("pre",{class:"language-typescript"},[e("code",null,[e("span",{class:"token keyword"},"import"),o(),e("span",{class:"token punctuation"},"{"),o(" Application "),e("span",{class:"token punctuation"},"}"),o(),e("span",{class:"token keyword"},"from"),o(),e("span",{class:"token string"},'"https://deno.land/x/oak/mod.ts"'),e("span",{class:"token punctuation"},";"),o(`

`),e("span",{class:"token keyword"},"const"),o(" app "),e("span",{class:"token operator"},"="),o(),e("span",{class:"token keyword"},"new"),o(),e("span",{class:"token class-name"},"Application"),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(),e("span",{class:"token comment"},"// or whatever you're using"),o(`

`),e("span",{class:"token comment"},"// Make sure to specify the framework you use."),o(`
app`),e("span",{class:"token punctuation"},"."),e("span",{class:"token function"},"use"),e("span",{class:"token punctuation"},"("),e("span",{class:"token function"},"webhookCallback"),e("span",{class:"token punctuation"},"("),o("bot"),e("span",{class:"token punctuation"},","),o(),e("span",{class:"token string"},'"oak"'),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},";"),o(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),D=o("Be sure to read "),G={href:"https://core.telegram.org/bots/webhooks",target:"_blank",rel:"noopener noreferrer"},z=o("Marvin\u2019s Marvellous Guide to All Things Webhook"),F=o(" written by the Telegram team if you consider running your bot on webhooks on a VPS."),V=n('<h3 id="webhook-reply" tabindex="-1"><a class="header-anchor" href="#webhook-reply" aria-hidden="true">#</a> Webhook Reply</h3><p>When a webhook request is received, your bot can call up to one method in the response. As a benefit, this saves your bot from making up to one HTTP request per update. However, there are a number of drawbacks to using this:</p><ol><li>You will not be able to handle potential errors of the respective API call. This includes rate limiting errors, so you won\u2019t actually be guaranteed that your request has any effect.</li><li>More importantly, you also won\u2019t have access to the response object. For example, calling <code>send<wbr>Message</code> will not give you access to the message you send.</li><li>Furthermore, it is not possible to cancel the request. The <code>Abort<wbr>Signal</code> will be disregarded.</li><li>Note also that the types in grammY do not reflect the consequences of a performed webhook callback! For instance, they indicate that you always receive a response object, so it is your own responsibility to make sure you\u2019re not screwing up while using this minor performance optimization.</li></ol>',3),M=o("If you want to use webhook replies, you can specify the "),J=e("code",null,[o("can"),e("wbr"),o("Use"),e("wbr"),o("Webhook"),e("wbr"),o("Reply")],-1),K=o(" option in the "),Q=e("code",null,"client",-1),X=o(" option of your "),Z=e("code",null,[o("Bot"),e("wbr"),o("Config")],-1),$=o(" ("),ee={href:"https://doc.deno.land/https://deno.land/x/grammy/mod.ts/~/BotConfig",target:"_blank",rel:"noopener noreferrer"},oe=o("API reference"),te=o("). Pass a function that determines whether or not to use webhook reply for the given request, identified by method."),ne=n(`<div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> bot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bot</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  client<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// We accept the drawback of webhook replies for typing status.</span>
    <span class="token function-variable function">canUseWebhookReply</span><span class="token operator">:</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> method <span class="token operator">===</span> <span class="token string">&quot;sendChatAction&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is how webhook replies work under the hood.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                   _____________
|            |                                   |           |
|            |                                   |           |
|            |                                   |           |
|            |         *both waiting*            |           |
|            |                                   |           |
|  Telegram  |                                   |    Bot    |
|            |                                   |           |
|            |                                   |           |
|            |    ---  hi, new message   ---&gt;    |           |
|            | &lt;--- okay, and sendChatAction --- |           |
|____________|                                   |___________|
</code></pre></div><h3 id="ending-webhook-requests-in-time" tabindex="-1"><a class="header-anchor" href="#ending-webhook-requests-in-time" aria-hidden="true">#</a> Ending Webhook Requests in Time</h3><blockquote><p>You can ignore the rest of this page if all your middleware completes fast, i.e. within a few seconds. This section is primarily for people who want to do file transfers in response to messages, or other operations that need more time.</p></blockquote>`,5),se=o("When Telegram sends an update from one chat to your bot, it will wait for you to end the request before delivering the next update that belongs to that chat. In other words, Telegram will deliver updates from the same chat in sequence, and updates from different chats are sent concurrently. (The source of this information is "),ae={href:"https://github.com/tdlib/telegram-bot-api/issues/75#issuecomment-755436496",target:"_blank",rel:"noopener noreferrer"},re=o("here"),ie=o(".)"),le=n(`<p>Telegram tries to make sure that your bot receives all updates. That means that if an update delivery fails for a chat, the subsequent updates will be queued until the first update succeeds.</p><h4 id="why-not-ending-a-webhook-request-is-dangerous" tabindex="-1"><a class="header-anchor" href="#why-not-ending-a-webhook-request-is-dangerous" aria-hidden="true">#</a> Why Not Ending a Webhook Request Is Dangerous</h4><p>Telegram has a timeout for each update that it sends to your webhook endpoint. If you don\u2019t end a webhook request fast enough, Telegram will re-send the update, assuming that it was not delivered. As a result, your bot can unexpectedly process the same update multiple times. This means that it will perform all update handling, including the sending of any response messages, multiple times.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                   _____________
|            |                                   |           |
|            | ---    hi, new message    ---&gt;    |           |
|            |                              .    |           |
|            |        *bot processing*      .    |           |
|            |                              .    |           |
|  Telegram  | --- I said new message!!! ---&gt;    |    Bot    |
|            |                              ..   |           |
|            |    *bot processing twice*    ..   |           |
|            |                              ..   |           |
|            | ---      HEEELLLOOOO      ---&gt;    |           |
|            |                              ...  |           |
|            |   *bot processing thrice*    ...  |           |
|____________|                              ...  |___________|
</code></pre></div><p>This is why grammY has its own, shorter timeout inside <code>webhook<wbr>Callback</code> (default: 10 seconds). If your middleware finishes before that, the function <code>webhook<wbr>Callback</code> will respond to the webhook automatically. In that case, everything is fine. However, if your middleware does not finish before grammY\u2019s timeout, <code>webhook<wbr>Callback</code> will throw an error. This means that you can handle the error in your web framework. If you don\u2019t have that error handling, Telegram will send the same update again\u2014but at least you will have error logs now, to tell you that something is wrong.</p><p>Once Telegram sends an update to your bot for the second time, it is unlikely that your handling of it will be faster than the first time. As a result, it will likely timeout again, and Telegram will send the update again. Thus, your bot will not just see the update two times, but a few dozen times, until Telegram stops retrying. You may observe that your bot starts spamming users as it tries to handle all of those updates (that are in fact the same every time).</p><h4 id="why-ending-a-webhook-request-early-is-also-dangerous" tabindex="-1"><a class="header-anchor" href="#why-ending-a-webhook-request-early-is-also-dangerous" aria-hidden="true">#</a> Why Ending a Webhook Request Early Is Also Dangerous</h4><p>You can configure <code>webhook<wbr>Callback</code> to not throw an error after the timeout, but instead end the webhook request early, even though your middleware is still running. You can do this by passing <code>&quot;return&quot;</code> as a third argument to <code>webhook<wbr>Callback</code>, instead of the default value <code>&quot;throw&quot;</code>. However, while this behavior has some valid use cases, such a solution usually causes more problems than it solves.</p>`,8),ce=o("Remember that once you respond to a webhook request, Telegram will send the next update for that chat. However, as the old update is still being processed, two updates which were previously processed sequentially, are suddenly processed in parallel. This can lead to race conditions. For example, the session plugin will inevitably break due to "),ue={href:"https://en.wikipedia.org/wiki/Hazard_(computer_architecture)#Write_after_read_(WAR)",target:"_blank",rel:"noopener noreferrer"},he=o("WAR"),de=o(" hazards. "),pe=e("strong",null,"This causes data loss!",-1),me=o(" Other plugins and even your own middleware may break too. The extent of this is unknown and depends on your bot."),_e=n(`<h4 id="how-to-solve-this-problem" tabindex="-1"><a class="header-anchor" href="#how-to-solve-this-problem" aria-hidden="true">#</a> How to Solve This Problem</h4><p>This answer is easier said than done. <strong>It is your job to make sure that your middleware finishes fast enough.</strong> Don\u2019t use long-running middleware. Yes, we know that you perhaps <em>want</em> to have long-running tasks. Still. Don\u2019t do it. Not in your middleware.</p><p>Instead, use a queue (there are plenty of queuing systems out there, from very simple to very sophisticated). Instead of trying to perform all of the work in the small webhook timeout window, just append the task to the queue to be handled separately, and let your middleware complete. The queue can use all the time it wants. When it\u2019s done, it can send a message back to the chat. This is straightforward to do if you just use a simple in-memory queue. It can be a little more challenging if you\u2019re using a fault-tolerant external queuing system, that persists the state of all tasks, and can retry things even if your server suddenly dies.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                   _____________
|            |                                   |           |
|            |   ---   hi, new message    ---&gt;   |           |
|            |  &lt;---     thanks dude      ---.   |           |
|            |                               .   |           |
|            |                               .   |           |
|  Telegram  |      *bot queue working*      .   |    Bot    |
|            |                               .   |           |
|            |                               .   |           |
|            |  &lt;--- message with result  ---    |           |
|            |   ---       alrighty       ---&gt;   |           |
|____________|                                   |___________|
</code></pre></div><h4 id="why-return-is-generally-worse-than-throw" tabindex="-1"><a class="header-anchor" href="#why-return-is-generally-worse-than-throw" aria-hidden="true">#</a> Why <code>&quot;return&quot;</code> Is Generally Worse Than <code>&quot;throw&quot;</code></h4><p>You may be wondering why the default action of <code>webhook<wbr>Callback</code> is to throw an error, instead of ending the request successfully. This design choice was made for the following reasons.</p><p>Race conditions are very hard to reproduce and may occur extremely rarely or sporadically. The solution to this is to <em>make sure not to run into timeouts</em> in the first place. But, if you do, you really want to know that this is happening, so that you can investigate and fix the problem! For that reason, you want the error to occur in your logs. Setting the timeout handler to <code>&quot;return&quot;</code>, hence suppressing the timeout and pretending that nothing happened, is exactly the opposite of useful behavior.</p><p>If you do this, you\u2019re in some sense using the update queue in Telegram\u2019s webhook delivery as your task queue. This is a bad idea for all of the reasons described above. Just because grammY <em>can</em> suppress errors that can make you lose your data, does not mean you <em>should</em> tell it to. This configuration setting should not be used in cases where your middleware simply takes too much time to complete. Take the time to correctly fix this issue, and your future self (and users) will thank you.</p>`,8);function ge(we,ye){const s=r("ExternalLinkIcon"),l=r("RouterLink"),i=r("CodeGroupItem"),c=r("CodeGroup");return h(),d("div",null,[m,e("blockquote",null,[e("p",null,[_,e("a",g,[w,t(s)]),y])]),k,e("p",null,[b,f,v,T,e("a",q,[x,t(s)]),I]),Y,W,C,A,e("p",null,[S,t(l,{to:"/guide/middleware.html"},{default:a(()=>[j]),_:1}),L]),O,e("p",null,[R,t(l,{to:"/plugins/runner.html"},{default:a(()=>[B]),_:1}),H]),P,t(c,null,{default:a(()=>[t(i,{title:"TypeScript",active:""},{default:a(()=>[N]),_:1}),t(i,{title:"JavaScript"},{default:a(()=>[U]),_:1}),t(i,{title:"Deno"},{default:a(()=>[E]),_:1})]),_:1}),e("p",null,[D,e("a",G,[z,t(s)]),F]),V,e("p",null,[M,J,K,Q,X,Z,$,e("a",ee,[oe,t(s)]),te]),ne,e("p",null,[se,e("a",ae,[re,t(s)]),ie]),le,e("p",null,[ce,e("a",ue,[he,t(s)]),de,pe,me]),_e])}const be=u(p,[["render",ge],["__file","deployment-types.html.vue"]]);export{be as default};
