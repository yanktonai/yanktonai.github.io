import{_ as m,r as u,o as l,c as p,a,b as e,w as s,e as i,d as n}from"./app.81c9d145.js";const d={},g=i(`<h1 id="long-polling-vs-webhook" tabindex="-1"><a class="header-anchor" href="#long-polling-vs-webhook" aria-hidden="true">#</a> Long Polling vs. Webhook</h1><p>Bot menerima pesan dari server Telegram dengan dua metode: <em>long polling</em> dan <em>webhook</em>. grammY mendukung keduanya dan secara bawaan menggunakan metode long polling.</p><p>Pertama, kami akan menjelaskan apa itu long polling dan webhook, kemudian menerangkan kelebihan dan kekurangan dari masing-masing metode tersebut. Materi ini juga mencakup cara-cara penerapannya menggunakan grammY.</p><h2 id="pengenalan" tabindex="-1"><a class="header-anchor" href="#pengenalan" aria-hidden="true">#</a> Pengenalan</h2><p>Kamu bisa membayangkan seluruh pembahasan webhook versus long polling sebagai pertanyaan <em>tipe deployment</em> apa yang harus dipilih. Dengan kata lain, terdapat dua cara yang berbeda dalam meng-hosting bot (menjalankannya di suatu server). Mereka juga memiliki metode pengiriman pesan yang berbeda.</p><p>Pilihan ini akan sangat berpengaruh jika kamu berencana memilih tempat hosting yang sesuai untuk bot kamu. Sebagai contoh, beberapa penyedia layanan hosting hanya mendukung salah satu dari dua metode deployment ini.</p><p>Bot kamu bisa <em>mengambil</em> update secara mandiri (long polling) ataupun menunggu server Telegram <em>mengirimkan</em> update ke bot kamu (webhook).</p><blockquote><p>Kalau kamu sudah tahu cara kerja dari kedua metode tersebut, gulir ke bawah untuk melihat bagaimana cara menggunakan <a href="#bagaimana-cara-menggunakan-long-polling">long polling</a> atau <a href="#bagaimana-cara-menggunakan-webhook">webhook</a> dengan grammY.</p></blockquote><h2 id="bagaimana-cara-kerja-long-polling" tabindex="-1"><a class="header-anchor" href="#bagaimana-cara-kerja-long-polling" aria-hidden="true">#</a> Bagaimana Cara Kerja Long Polling?</h2><p><em>Bayangkan kamu ingin membeli segelas es cendol di warung Pak Jenggot langgananmu. Kamu berjalan ke warung beliau lalu memesan es cendol durian. Sayangnya, es cendol durian lagi habis. Kamu balik pulang dengan tangan kosong sambil mata berkaca-kaca.</em></p><p><em>Besok harinya, kamu masih ingin merasakan nikmatnya es cendol durian. Kamu pergi ke warung Pak Jenggot dengan harap-harap cemas. Kabar baik! Es cendol durian sudah tersedia, bahkan stoknya melimpah ruah. Kamu menikmati setiap seruputan dengan senyuman lebar di wajah. Segar sekali!</em></p><p><strong>Polling</strong> artinya grammY secara proaktif mengirim request ke Telegram, meminta update baru (anggaplah pesan). Kalau tidak ada pesan yang tersedia, Telegram akan mengembalikan daftar kosong, yang menandakan bahwa tidak ada pesan baru untuk bot kamu semenjak terakhir kali kamu mengirim request.</p><p>Lalu grammY mengirim sebuah request lagi ke Telegram, dan ternyata pesan-pesan baru telah tersedia. Telegram lantas mengembalikan pesan-pesan tersebut dalam bentuk sebuah array yang berisi maksimal 100 object update.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                              _____________
|            |                                              |           |
|            |    &lt;---       Apa ada pesan baru?     ---    |           |
|            |     ---         maaf, tidak ada       ---&gt;   |           |
|            |                                              |           |
|            |    &lt;---       Apa ada pesan baru?     ---    |           |
|  Telegram  |     ---         maaf, tidak ada       ---&gt;   |    Bot    |
|            |                                              |           |
|            |    &lt;---      Apa ada pesan baru?      ---    |           |
|            |     ---   Oh! iya ada, ini pesannya   ---&gt;   |           |
|            |                                              |           |
|____________|                                              |___________|
</code></pre></div><p>Terlihat jelas bahwa cara ini memiliki beberapa kekurangan. Bot kamu hanya akan menerima pesan baru jika ia memintanya, misal setiap beberapa detik, dsb. Supaya bot kamu bisa merespon dengan cepat, kamu cuma perlu mengirim request sebanyak-banyaknya dan tak perlu menunggu balasan satu demi satu. Contohnya, kita bisa saja meminta pesan baru setiap 1 milidetik! Tidak ada salahnya bukan\u2026</p><p>Daripada mengirim spam ke server Telegram, kita akan menggunakan <em>long polling</em> alih-alih (short) polling biasa.</p><p><strong>Long polling</strong> berarti grammY secara proaktif mengirim sebuah request ke Telegram untuk meminta update baru. Kalau tidak ada pesan baru, Telegram akan menjaga koneksi tetap tersambung hingga pesan baru tiba, yang kemudian akan merespon request dengan pesan-pesan baru tersebut.</p><p><em>Kembali ke es cendol Pak Jenggot! Kali ini kamu minta es cendol alpukat. Pak Jenggot tersenyum lalu tiba-tiba diam mematung. Bahkan, kamu tidak mendapatkan respon sama sekali. Jadi, kamu pun menunggu sambil tersenyum kembali ke Pak Jenggot. Masih menunggu\u2026 Dan menunggu\u2026</em></p><p><em>Beberapa menit sebelum matahari terbit, sebuah mobil pickup tiba dengan membawa beberapa wadah besar menuju gudang pendingin di belakang warung. Di wadah-wadah itu terdapat label besar bertuliskan <strong>ES CENDOL ALPUKAT</strong>.</em></p><p><em>Pak Jenggot tiba-tiba mulai bergerak lagi. Beliau menyahut \u201COk, siap! Kami punya stok es cendol alpukat banyak di gudang! Satu porsi extra ditambah krim susu, dibungkus seperti biasanya?\u201D</em></p><p><em>Seolah-olah tidak terjadi apa-apa, kamu membawa es cendol sambil berjalan pulang meninggalkan warung es cendol paling aneh sedunia.</em></p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                            _____________
|            |                                            |           |
|            |   &lt;---     Apa ada pesan baru?      ---    |           |
|            |   .                                        |           |
|            |   .                                        |           |
|            |   .       *Dua-duanya menunggu*            |           |
|  Telegram  |   .                                        |    Bot    |
|            |   .                                        |           |
|            |   .                                        |           |
|            |    ---  Oh! iya ada, ini pesannya   ---&gt;   |           |
|            |                                            |           |
|____________|                                            |___________|
</code></pre></div>`,22),c=n("Perlu dicatat bahwa pada kenyataannya, tidak ada koneksi yang akan tetap terbuka selama berjam-jam. Request long polling mempunyai waktu timeout bawaan selama 30 detik untuk menghindari terjadinya berbagai "),b={href:"https://tools.ietf.org/id/draft-loreto-http-bidirectional-07.html#timeouts",target:"_blank",rel:"noopener noreferrer"},h=n("masalah teknis"),_=n(". Kalau tidak ada pesan baru yang dikembalikan selama periode waktu tersebut, maka request akan dibatalkan dan dikirimkan kembali\u2014tetapi konsep dasarnya masih tetap sama."),y=i(`<p>Dengan menggunakan long polling, kamu akan menerima pesan baru yang sama cepatnya, sehingga tidak perlu lagi mengirim spam ke server Telegram. Metode inilah yang akan dipakai grammY ketika kamu menjalankan <code>bot<wbr>.start()</code>. Mantap!</p><h2 id="bagaimana-cara-kerja-webhook" tabindex="-1"><a class="header-anchor" href="#bagaimana-cara-kerja-webhook" aria-hidden="true">#</a> Bagaimana Cara Kerja Webhook?</h2><p><em>Setelah kejadian menyeramkan yang kamu alami (seminggu tanpa es cendol!), kamu pun memutuskan untuk tidak membeli es cendol dari orang lain, selamanya. Daripada kamu keluar rumah setiap kali ingin membeli es cendol, bukankah lebih baik kalau es cendolnya dikirim ke rumahmu?</em></p><p>Menggunakan <strong>webhook</strong> berarti kamu akan memberikan sebuah URL (yang bisa diakses oleh publik) ke Telegram. Kapanpun ada pesan baru tersedia untuk bot-mu, Telegram (bukan kamu!) akan mengambil inisiatif untuk mengirim request beserta object update-nya ke server-mu. Keren, kan?</p><p><em>Kamu memutuskan untuk mengunjungi warung es cendol untuk yang terakhir kalinya. Kamu memberi tahu Pak Jenggot alamat rumahmu. Setelah itu, beliau berjanji untuk langsung mengantarkan es cendolnya setiap kali ada stok baru tersedia, sendiri (karena beliau bilang es cendolnya keburu cair kalau diantar dengan jasa ekspedisi). Pak Jenggot benar-benar penjual yang ramah dan baik hati.</em></p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                                _____________
|            |                                                |           |
|            |                                                |           |
|            |                                                |           |
|            |            *Kedua-duanya menunggu*             |           |
|            |                                                |           |
|  Telegram  |                                                |    Bot    |
|            |                                                |           |
|            |                                                |           |
|            |    ---     Permisi, ada pesan baru    ---&gt;     |           |
|            |   &lt;---      Oh, iya. Terima kasih!    ---      |           |
|____________|                                                |___________|
</code></pre></div><h2 id="perbandingan" tabindex="-1"><a class="header-anchor" href="#perbandingan" aria-hidden="true">#</a> Perbandingan</h2><p><strong>Keuntungan utama long polling dibandingkan dengan webhook adalah lebih simpel.</strong> Kamu tidak perlu menyediakan sebuah domain atau URL publik, serta mengotak-atik sertifikat SSL kalau kamu menjalankan bot di sebuah VPS. Cukup gunakan <code>bot<wbr>.start()</code> dan semuanya akan berjalan dengan baik, tidak perlu pengaturan lebih lanjut. Bot juga tidak terbebani karena kamu memiliki kontrol atas jumlah pesan yang ingin diproses.</p><p>Tempat-tempat yang cocok untuk menggunakan long polling:</p><ul><li>Di komputermu sendiri ketika mengembangkan bot.</li><li>Di kebanyakan server.</li><li>Di tempat hosting yang menjalankan bot kamu selama 24 jam sehari.</li></ul>`,10),w=a("strong",null,"Keuntungan utama webhook dibandingkan dengan long polling adalah lebih hemat.",-1),j=n(" Kamu bisa menghemat banyak sekali request dan tidak perlu lagi menjaga koneksi tetap tersambung sepanjang waktu. Kamu bisa menggunakan layanan hosting yang secara otomatis menurunkan performa ketika tidak ada request yang masuk, yang berarti lebih hemat biaya. Kalau mau, kamu bahkan bisa "),f=a("a",{href:"#webhook-reply"},"membuat panggilan API ketika membalas request dari Telegram",-1),v=n(", walaupun ia juga memiliki beberapa kekurangan yang harus diperhitungkan juga. Lihat konfigurasi opsinya "),q={href:"https://doc.deno.land/https://deno.land/x/grammy/mod.ts/~/ApiClientOptions#canUseWebhookReply",target:"_blank",rel:"noopener noreferrer"},K=n("di sini"),T=n("."),x=a("p",null,"Tempat-tempat yang cocok untuk menggunakan webhook:",-1),B=a("ul",null,[a("li",null,"Di server yang menggunakan sertifikat SSL."),a("li",null,"Di tempat hosting yang memasang tarif berdasarkan beban yang dipakai."),a("li",null,"Di platform serverless, misal cloud function atau edge network yang terprogram.")],-1),S=a("h2",{id:"aku-masih-belum-tahu-mana-yang-sebaiknya-dipilih",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#aku-masih-belum-tahu-mana-yang-sebaiknya-dipilih","aria-hidden":"true"},"#"),n(" Aku Masih Belum Tahu Mana yang Sebaiknya Dipilih")],-1),P=a("p",null,[n("Jika kamu tidak punya alasan yang bagus untuk menggunakan webhook, pilih saja long polling. Long polling tidak memiliki kekurangan yang mencolok, dan\u2014berdasarkan pengalaman kami\u2014kamu tidak perlu membuang-buang waktu melakukan perawatan atau maintenance. Webhook bisa menjadi sedikit \u201Cnakal\u201D dari waktu ke waktu (lihat "),a("a",{href:"#mengakhiri-request-webhook-tepat-waktu"},"di bawah"),n(").")],-1),C=n("Apapun pilihannya, disaat kamu mengalami masalah yang cukup serius, seharusnya tidak terlalu sulit untuk beralih dari satu metode deployment ke metode deployment yang lain. Di grammY, kamu cukup menulis beberapa baris kode. Selain itu, kamu tidak perlu mengubah pengaturan "),A=n("middleware"),D=n("."),L=i(`<h2 id="bagaimana-cara-menggunakan-long-polling" tabindex="-1"><a class="header-anchor" href="#bagaimana-cara-menggunakan-long-polling" aria-hidden="true">#</a> Bagaimana Cara Menggunakan Long Polling</h2><p>Panggil</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>bot<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>untuk menjalankan bot kamu menggunakan bentuk paling simpel dari long polling. Ia akan memproses update secara berurutan. Sangat mudah untuk men-debug bot kamu menggunakan metode ini. Semua perilaku bisa dengan mudah diprediksi karena update dikerjakan secara berurutan bukan bersamaan.</p>`,4),J=n("Jika kamu ingin grammY untuk memproses pesan secara bersamaan, atau kamu khawatir dengan output yang dihasilkan, silahkan lihat materi yang membahas tentang "),M=n("grammY runner"),Y=n("."),R=i('<h2 id="bagaimana-cara-menggunakan-webhook" tabindex="-1"><a class="header-anchor" href="#bagaimana-cara-menggunakan-webhook" aria-hidden="true">#</a> Bagaimana Cara Menggunakan Webhook</h2><p>Kalau kamu ingin menggunakan webhook, kamu harus mengintegrasikan bot kamu ke dalam web server. Oleh karena itu, kami berharap kamu mampu menjalankan sebuah web server sederhana menggunakan framework pilihanmu.</p><p>Setiap bot di grammY bisa dikonversi menjadi middleware untuk beberapa web framework, termasuk <code>express</code>, <code>koa</code>/<code>oak</code>, dsb. Kamu bisa meng-import function <code>webhook<wbr>Callback</code> dari grammY untuk mengonversi bot-mu menjadi middleware untuk framework yang diinginkan.</p>',3),I=a("div",{class:"language-typescript ext-ts line-numbers-mode"},[a("pre",{class:"language-typescript"},[a("code",null,[a("span",{class:"token keyword"},"import"),n(" express "),a("span",{class:"token keyword"},"from"),n(),a("span",{class:"token string"},'"express"'),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token keyword"},"const"),n(" app "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token function"},"express"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// atau framework apapun yang kamu gunakan"),n(`
app`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"use"),a("span",{class:"token punctuation"},"("),n("express"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"json"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// mengurai (parsing) body dari request JSON"),n(`

`),a("span",{class:"token comment"},'// "express" akan otomatis dipakai jika tidak ada argument yang diberikan.'),n(`
app`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"use"),a("span",{class:"token punctuation"},"("),a("span",{class:"token function"},"webhookCallback"),a("span",{class:"token punctuation"},"("),n("bot"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token string"},'"express"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),W=a("div",{class:"language-javascript ext-js line-numbers-mode"},[a("pre",{class:"language-javascript"},[a("code",null,[a("span",{class:"token keyword"},"const"),n(" express "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token function"},"require"),a("span",{class:"token punctuation"},"("),a("span",{class:"token string"},'"express"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token keyword"},"const"),n(" app "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token function"},"express"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// atau framework apapun yang kamu gunakan"),n(`
app`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"use"),a("span",{class:"token punctuation"},"("),n("express"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"json"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// mengurai (parsing) body dari request JSON"),n(`

`),a("span",{class:"token comment"},'// "express" akan otomatis dipakai jika tidak ada argument yang diberikan.'),n(`
app`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"use"),a("span",{class:"token punctuation"},"("),a("span",{class:"token function"},"webhookCallback"),a("span",{class:"token punctuation"},"("),n("bot"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token string"},'"express"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),O=a("div",{class:"language-typescript ext-ts line-numbers-mode"},[a("pre",{class:"language-typescript"},[a("code",null,[a("span",{class:"token keyword"},"import"),n(),a("span",{class:"token punctuation"},"{"),n(" Application "),a("span",{class:"token punctuation"},"}"),n(),a("span",{class:"token keyword"},"from"),n(),a("span",{class:"token string"},'"https://deno.land/x/oak/mod.ts"'),a("span",{class:"token punctuation"},";"),n(`

`),a("span",{class:"token keyword"},"const"),n(" app "),a("span",{class:"token operator"},"="),n(),a("span",{class:"token keyword"},"new"),n(),a("span",{class:"token class-name"},"Application"),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(),a("span",{class:"token comment"},"// atau framework apapun yang kamu gunakan"),n(`

`),a("span",{class:"token comment"},"// Pastikan untuk mencantumkan nama framework-nya."),n(`
app`),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"use"),a("span",{class:"token punctuation"},"("),a("span",{class:"token function"},"webhookCallback"),a("span",{class:"token punctuation"},"("),n("bot"),a("span",{class:"token punctuation"},","),n(),a("span",{class:"token string"},'"oak"'),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),n(`
`)])]),a("div",{class:"line-numbers","aria-hidden":"true"},[a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"}),a("div",{class:"line-number"})])],-1),N=n("Jika kamu berniat menjalankan bot di sebuah VPS menggunakan webhook, pastikan untuk membaca "),E={href:"https://core.telegram.org/bots/webhooks",target:"_blank",rel:"noopener noreferrer"},U=n("panduan keren Marvin mengenai hal"),V=a("wbr",null,null,-1),G=n("-hal tentang webhook"),H=n(" yang ditulis oleh tim Telegram."),z=i('<h3 id="webhook-reply" tabindex="-1"><a class="header-anchor" href="#webhook-reply" aria-hidden="true">#</a> Webhook Reply</h3><p>Ketika menerima sebuah request webhook, bot kamu bisa memanggil satu method sebagai responnya. Keuntungannya, bot kamu bisa menghemat satu request HTTP per update. Tetapi, terdapat beberapa kekurangan dibaliknya:</p><ol><li>Kamu tidak bisa mengatasi error yang mungkin terjadi ketika melakukan panggilan API tersebut. Termasuk diantaranya adalah error rate limit. Jadi, tidak ada jaminan kalau request-mu berjalan dengan baik.</li><li>Yang paling penting, kamu tidak memiliki akses ke object responnya. Misal, ketika memanggil <code>send<wbr>Message</code> kamu tidak akan menerima balasan berupa isi pesan yang telah kamu kirim.</li><li>Bahkan, kamu tidak bisa membatalkan request-nya. <code>Abort<wbr>Signal</code> akan diabaikan.</li><li>Perlu diperhatikan juga bahwa beberapa type di grammY tidak mencerminkan hasil dari callback webhook yang telah dilakukan! Sebagai contoh, mereka akan selalu mengindikasikan bahwa kamu telah menerima object respon, sehingga ini menjadi tanggung jawab kamu untuk memastikan semua berjalan baik ketika melakukan optimasi kecil ini.</li></ol>',3),Q=n("Kalau kamu ingin memanfaatkan webhook reply, kamu bisa menambahkan opsi "),F=a("code",null,[n("can"),a("wbr"),n("Use"),a("wbr"),n("Webhook"),a("wbr"),n("Reply")],-1),X=n("di opsi "),Z=a("code",null,"client",-1),$=n(" dari "),aa=a("code",null,[n("Bot"),a("wbr"),n("Config")],-1),na=n(" kamu ("),ea={href:"https://doc.deno.land/https://deno.land/x/grammy/mod.ts/~/BotConfig",target:"_blank",rel:"noopener noreferrer"},ia=n("referensi API"),ta=n("). Masukkan sebuah function yang menentukan apakah method tersebut memanfaatkan webhook reply atau tidak."),sa=i(`<div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> bot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bot</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  client<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// Kita hanya akan menggunakan webhook reply</span>
    <span class="token comment">// jika method tersebut adalah &quot;sendChatAction&quot;.</span>
    <span class="token function-variable function">canUseWebhookReply</span><span class="token operator">:</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> method <span class="token operator">===</span> <span class="token string">&quot;sendChatAction&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Berikut cara kerja webhook reply di balik layar:</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                                       _____________
|            |                                                       |           |
|            |                                                       |           |
|            |                                                       |           |
|            |               *Kedua-duanya menunggu*                 |           |
|            |                                                       |           |
|  Telegram  |                                                       |    Bot    |
|            |                                                       |           |
|            |                                                       |           |
|            |  ---          Permisi, ada pesan baru            ---&gt; |           |
|            | &lt;--- Baik, sekalian kirim sendChatAction ini, ya ---  |           |
|____________|                                                       |___________|
</code></pre></div><h3 id="mengakhiri-request-webhook-tepat-waktu" tabindex="-1"><a class="header-anchor" href="#mengakhiri-request-webhook-tepat-waktu" aria-hidden="true">#</a> Mengakhiri Request Webhook Tepat Waktu</h3><blockquote><p>Kamu bisa mengabaikan sisa dari halaman ini jika middleware kamu cukup cepat, misal dalam beberapa detik saja. Bagian ini ditujukan khusus untuk kamu yang ingin melakukan operasi-operasi yang membutuhkan waktu cukup lama, contohnya pengiriman file.</p></blockquote>`,5),ua=n("Saat Telegram mengirim sebuah update dari sebuah chat ke bot kamu, ia akan menunggu kamu mengakhiri request tersebut sebelum mengirim update berikutnya dari chat yang sama. Dengan kata lain, Telegram akan mengirim update dari chat yang sama secara "),ra=a("strong",null,"berurutan",-1),oa=n(", sebaliknya update dari chat yang berbeda akan dikirim secara "),ka=a("strong",null,"bersamaan",-1),ma=n(". Sumber informasi tersebut berasal dari "),la={href:"https://github.com/tdlib/telegram-bot-api/issues/75#issuecomment-755436496",target:"_blank",rel:"noopener noreferrer"},pa=n("sini"),da=n("."),ga=i(`<p>Telegram selalu memastikan kalau bot kamu menerima semua update yang dikirimkan. Berarti, jika sebuah update gagal dikirim, ia akan menunda pengiriman update-update selanjutnya hingga update yang pertama tadi berhasil diterima oleh bot kamu.</p><h4 id="kenapa-tidak-mengakhiri-request-webhook-itu-berbahaya" tabindex="-1"><a class="header-anchor" href="#kenapa-tidak-mengakhiri-request-webhook-itu-berbahaya" aria-hidden="true">#</a> Kenapa Tidak Mengakhiri Request Webhook Itu Berbahaya</h4><p>Telegram mempunyai timeout atau batas waktu untuk setiap update yang dikirim ke alamat webhook kamu. Kalau kamu telat mengakhiri webhook, Telegram akan mengirim kembali update tersebut karena ia mengasumsikan update-nya gagal dikirim. Akibatnya, bot kamu secara tidak sengaja memproses update yang sama berulang kali, termasuk mengirim pesan ke pengguna.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                                       _____________
|            |                                                       |           |
|            | ---          Permisi, ada pesan baru          ---&gt;    |           |
|            |                                                  .    |           |
|            |            *bot langsung memprosesnya*           .    |           |
|            |                                                  .    |           |
|  Telegram  | ---           PERMISI! pesan baru!            ---&gt;    |    Bot    |
|            |                                                  ..   |           |
|            |     *bot memproses untuk yang kedua kalinya*     ..   |           |
|            |                                                  ..   |           |
|            | ---           HALOOO?! ADA ORANG?!            ---&gt;    |           |
|            |                                                  ...  |           |
|            |     *bot memproses untuk yang ketiga kalinya*    ...  |           |
|____________|                                                  ...  |___________|
</code></pre></div><p>Itulah kenapa grammY memiliki timeout-nya sendiri. <code>webhook<wbr>Callback</code> memiliki timeout yang lebih pendek, sebesar 10 detik untuk setting-an bawaan. Kalau middleware kamu selesai sebelum batas waktu tersebut, function <code>webhook<wbr>Callback</code> akan merespon webhook secara otomatis. Semua berjalan lancar. Tetapi, kalau middleware kamu melewati batas timeout milik grammY, <code>webhook<wbr>Callback</code> akan melempar sebuah error. Artinya, kamu perlu menangani error tersebut di web framework-mu. Kalau kamu tidak memiliki error handler untuk menanganinya, Telegram akan mengirim kembali update yang sama. Setidaknya kali ini kamu memiliki log error yang bisa memberi tahu dimana letak kesalahannya.</p><p>Saat Telegram mengirim update yang sama untuk kedua kalinya, kemungkinan besar bot kamu akan melewati batas timeout lagi dan Telegram akan tetap mengirim update tersebut. Bot kamu tidak hanya akan menerima update yang sama dua kali, bahkan berkali-kali hingga Telegram memutuskan untuk berhenti mengirimkannya. Kamu akan mulai menyadari bahwa bot-mu mengirim spam ke para user karena ia memproses update yang sama berulang kali, yang kemungkinan besar isi pesannya juga sama.</p><h4 id="kenapa-mengakhiri-request-webhook-lebih-awal-juga-berbahaya" tabindex="-1"><a class="header-anchor" href="#kenapa-mengakhiri-request-webhook-lebih-awal-juga-berbahaya" aria-hidden="true">#</a> Kenapa Mengakhiri Request Webhook Lebih Awal Juga Berbahaya</h4><p>Daripada melempar sebuah error saat terjadi timeout, kamu bisa saja mengonfigurasi <code>webhook<wbr>Callback</code> untuk mengakhiri request webhook tersebut lebih awal, meskipun middleware kamu masih memproses pesan. Kamu bisa melakukannya dengan memasukkan <code>&quot;return&quot;</code> sebagai argument ketiga ke <code>webhook<wbr>Callback</code>, alih-alih value bawaan <code>&quot;throw&quot;</code>. Meskipun bisa dilakukan, solusi seperti ini biasanya menyebabkan banyak masalah.</p>`,8),ca=n("Ingat! Ketika kamu merespon webhook, Telegram akan mengirim update berikutnya untuk chat yang sama. Namun, karena update yang lama masih dikerjakan, maka dua update yang seharusnya diproses berurutan sekarang diproses bersamaan. Ini akan menyebabkan "),ba=a("em",null,"race condition",-1),ha=n(". Contohnya, kerusakan di plugin session menjadi tidak terhindarkan karena "),_a={href:"https://en.wikipedia.org/wiki/Hazard_(computer_architecture)#Write_after_read_(WAR)",target:"_blank",rel:"noopener noreferrer"},ya=n("WAR"),wa=n(" hazard"),ja=n(". "),fa=a("strong",null,"Kondisi ini akan menyebabkan bot kehilangan data!",-1),va=n(" Plugin lainnya dan bahkan middleware-mu sendiri juga mungkin akan ikut rusak. Sejauh mana hal ini bisa dilakukan tergantung dari bot kamu."),qa=i(`<h4 id="bagaimana-cara-mengatasinya" tabindex="-1"><a class="header-anchor" href="#bagaimana-cara-mengatasinya" aria-hidden="true">#</a> Bagaimana Cara Mengatasinya</h4><p>Jawaban dari pertanyaan ini lebih mudah diucapkan daripada dilakukan: <strong>itu tugas kamu untuk memastikan semua middleware selesai sebelum batas timeout.</strong> Jangan gunakan middleware yang berjalan lama. Ya, kami paham kalau kamu mungkin <em>ingin</em> melakukan pekerjaan yang membutuhkan waktu lama. Tetap saja. Jangan lakukan hal tersebut. Tidak di dalam middleware kamu.</p><p>Lebih baik gunakan antrian atau queue (ada banyak sistem queue yang tersedia di luar sana, dari yang paling simpel hingga paling rumit). Daripada melakukan semua pekerjaan di dalam webhook yang memiliki timeout terbatas, lebih baik kamu menambahkan tugas baru ke antrian queue yang diproses terpisah, dan biarkan middleware kamu menyelesaikan tugasnya sendiri. Queue tersebut bisa menggunakan waktu sebanyak yang ia mau. Ketika sudah selesai, ia bisa mengirim pesan kembali ke chat. Ini cukup mudah dilakukan kalau kamu hanya menggunakan queue sederhana di memory. Tetapi, akan cukup menantang jika kamu menggunakan <em>fault-tolerant external queuing system</em>, yang mana dapat mempertahankan keadaan dari semua tugas, lalu kamu bisa melanjutkan antrian tugas tersebut meskipun server-mu tiba-tiba padam.</p><div class="language-asciiart ext-asciiart"><pre class="language-asciiart"><code>______________                                          _____________
|            |                                          |           |
|            |   ---     permisi, pesan baru     ---&gt;   |           |
|            |  &lt;---      ok, terima kasih       ---.   |           |
|            |                                      .   |           |
|            |                                      .   |           |
|  Telegram  |       *bot memulai antrian queue*    .   |    Bot    |
|            |                                      .   |           |
|            |                                      .   |           |
|            |  &lt;--- kirim pesan beserta hasilnya ---   |           |
|            |   ---     baik, sudah dikirim      ---&gt;  |           |
|____________|                                          |___________|
</code></pre></div><h4 id="kenapa-return-biasanya-lebih-buruk-daripada-throw" tabindex="-1"><a class="header-anchor" href="#kenapa-return-biasanya-lebih-buruk-daripada-throw" aria-hidden="true">#</a> Kenapa <code>&quot;return&quot;</code> Biasanya Lebih Buruk Daripada <code>&quot;throw&quot;</code></h4><p>Kamu mungkin penasaran kenapa perilaku bawaan <code>webhook<wbr>Callback</code> adalah melempar sebuah error, alih-alih mengakhiri request tersebut dengan baik. Pilihan desain ini dipilih karena pertimbangan berikut.</p><p>Race condition sangat sulit direproduksi dan bahkan mungkin sangat jarang terjadi atau cuma terjadi sekali-sekali saja. Solusinya adalah <em>pastikan tidak sampai terjadi timeout</em> dari awal. Jika itu dilakukan, kamu pasti ingin tahu apa yang sebenarnya terjadi, dengan begitu kamu bisa menyelidiki dan memperbaiki sumber masalahnya! Karena alasan tersebut, kamu mengharapkan sebuah error muncul di log kamu. Menyetel timeout handler ke <code>&quot;return&quot;</code>, mengabaikan timeout dan berpura-pura seolah-olah tidak terjadi apa-apa, adalah kebalikan dari perilaku yang kita inginkan dan tidak membantu sama sekali.</p><p>Kalau kamu tetap melakukannya, kamu seakan-akan menggunakan antrian update di pengiriman webhook milik Telegram sebagai antrian queue milikmu. Ini ide yang buruk karena alasan-alasan yang telah dijabarkan di atas. Hanya karena grammY <em>bisa</em> menghilangkan error yang menyebabkan kamu kehilangan datamu, bukan berarti kamu <em>harus</em> menggunakannya. Konfigurasi ini sebaiknya tidak dipakai kalau kasusnya hanya karena middleware kamu membutuhkan waktu yang lama untuk menyelesaikan tugasnya. Luangkan waktu untuk memperbaiki isu tersebut, dengan begitu dirimu di masa depan tidak akan menyesalinya.</p>`,8);function Ka(Ta,xa){const t=u("ExternalLinkIcon"),o=u("RouterLink"),r=u("CodeGroupItem"),k=u("CodeGroup");return l(),p("div",null,[g,a("blockquote",null,[a("p",null,[c,a("a",b,[h,e(t)]),_])]),y,a("p",null,[w,j,f,v,a("a",q,[K,e(t)]),T]),x,B,S,P,a("p",null,[C,e(o,{to:"/id/guide/middleware.html"},{default:s(()=>[A]),_:1}),D]),L,a("p",null,[J,e(o,{to:"/id/plugins/runner.html"},{default:s(()=>[M]),_:1}),Y]),R,e(k,null,{default:s(()=>[e(r,{title:"TypeScript",active:""},{default:s(()=>[I]),_:1}),e(r,{title:"JavaScript"},{default:s(()=>[W]),_:1}),e(r,{title:"Deno"},{default:s(()=>[O]),_:1})]),_:1}),a("p",null,[N,a("a",E,[U,V,G,e(t)]),H]),z,a("p",null,[Q,F,X,Z,$,aa,na,a("a",ea,[ia,e(t)]),ta]),sa,a("p",null,[ua,ra,oa,ka,ma,a("a",la,[pa,e(t)]),da]),ga,a("p",null,[ca,ba,ha,a("em",null,[a("a",_a,[ya,e(t)]),wa]),ja,fa,va]),qa])}const Sa=m(d,[["render",Ka],["__file","deployment-types.html.vue"]]);export{Sa as default};
